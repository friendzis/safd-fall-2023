/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ca;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.stream.IntStream;

public class App {

   /**
    * Performs date palindrominness test for each year in the given range and prints resulting date if it a palindrome.
    * Palindrominess test is performed by constructing a date from reversed stringified year and delegating date validity logic to date formatter
    *
    * @param fromYear year range start, inclusive
    * @param toYear year range end, inclusive
    */
   public static void printBonusDatesBetween(int fromYear, int toYear) throws IllegalArgumentException {
      // Basic argument sanity check assertions
      if (fromYear < 1583) {
         throw new IllegalArgumentException(String.format("Lower date bound not covered by ISO_8601"));
      }
      if (toYear > 9999) {
         throw new IllegalArgumentException(String.format("Upper date bound not covered by ISO_8601"));
      }

      for(int year : IntStream.rangeClosed(fromYear, toYear).toArray()) {
         try {
            // String.substring cannot reverse
            String yearReversed = new StringBuilder(Integer.toString(year)).reverse().toString();
            LocalDate date = LocalDate.parse(
               // No need for %04d shenanigans as we already guard against such values
               String.format("%d-%s-%s",
                  year,
                  yearReversed.substring(0, 2),
                  yearReversed.substring(2, 4)
               ),
               DateTimeFormatter.ISO_DATE);
            System.out.println(date);
         }
         catch(DateTimeParseException e) {
            // System.out.println(e);
         }
      }
    }

   public static void main(String[] args) {
      App.printBonusDatesBetween(2010, 2015);
   }
}
